#\n# @lc app=leetcode id=3501 lang=java\n#\n# [3501] Maximize Active Section with Trade II\n#\n\n# @lc code=start\nimport java.util.*;\nclass Solution {\n    public List<Integer> maxActiveSectionsAfterTrade(String s, int[][] queries) {\n        int n = s.length();\n        int totalOnes = 0;\n        for (int j = 0; j < n; j++) {\n            if (s.charAt(j) == '1') totalOnes++;\n        }\n        // Extract 0-runs\n        List<Integer> runLeft = new ArrayList<>();\n        List<Integer> runRight = new ArrayList<>();\n        List<Integer> runLen = new ArrayList<>();\n        int idx = 0;\n        while (idx < n) {\n            if (s.charAt(idx) == '1') {\n                idx++;\n                continue;\n            }\n            int st = idx;\n            while (idx < n && s.charAt(idx) == '0') idx++;\n            int en = idx - 1;\n            runLeft.add(st);\n            runRight.add(en);\n            runLen.add(en - st + 1);\n        }\n        int m = runLen.size();\n        List<Integer> ans = new ArrayList<>();\n        if (m == 0) {\n            for (int[] q : queries) {\n                ans.add(totalOnes);\n            }\n            return ans;\n        }\n        int[] LEFTS = new int[m];\n        int[] RIGHTS = new int[m];\n        int[] LENS = new int[m];\n        for (int j = 0; j < m; j++) {\n            LEFTS[j] = runLeft.get(j);\n            RIGHTS[j] = runRight.get(j);\n            LENS[j] = runLen.get(j);\n        }\n        int psize = m - 1;\n        int[] pairSums = psize > 0 ? new int[psize] : new int[0];\n        for (int k = 0; k < psize; k++) {\n            pairSums[k] = LENS[k] + LENS[k + 1];\n        }\n        // Sparse table\n        final int LOG = 16;\n        int[][] sparse = new int[LOG][psize];\n        if (psize > 0) {\n            for (int j = 0; j < psize; j++) {\n                sparse[0][j] = pairSums[j];\n            }\n            for (int lv = 1; lv < LOG; lv++) {\n                for (int j = 0; j + (1 << lv) <= psize; j++) {\n                    sparse[lv][j] = Math.max(sparse[lv - 1][j], sparse[lv - 1][j + (1 << (lv - 1))]);\n                }\n            }\n        }\n        // Process queries\n        for (int[] q : queries) {\n            int li = q[0], ri = q[1];\n            // jL: first >= li on RIGHTS\n            int jL = -1;\n            int lo = 0, hi = m - 1;\n            while (lo <= hi) {\n                int mid = (lo + hi) / 2;\n                if (RIGHTS[mid] >= li) {\n                    jL = mid;\n                    hi = mid - 1;\n                } else {\n                    lo = mid + 1;\n                }\n            }\n            if (jL == -1 || LEFTS[jL] > ri) {\n                ans.add(totalOnes);\n                continue;\n            }\n            // jR: last <= ri on LEFTS\n            int jR = -1;\n            lo = 0;\n            hi = m - 1;\n            while (lo <= hi) {\n                int mid = (lo + hi) / 2;\n                if (LEFTS[mid] <= ri) {\n                    jR = mid;\n                    lo = mid + 1;\n                } else {\n                    hi = mid - 1;\n                }\n            }\n            if (jR < jL) {\n                ans.add(totalOnes);\n                continue;\n            }\n            int numG = jR - jL + 1;\n            if (numG < 2) {\n                ans.add(totalOnes);\n                continue;\n            }\n            int clipL = Math.min(ri, RIGHTS[jL]) - Math.max(li, LEFTS[jL]) + 1;\n            int clipR = Math.min(ri, RIGHTS[jR]) - Math.max(li, LEFTS[jR]) + 1;\n            int gMax = clipL + ((jL + 1 == jR) ? clipR : LENS[jL + 1]);\n            if (numG >= 3) {\n                int lastSum = LENS[jR - 1] + clipR;\n                gMax = Math.max(gMax, lastSum);\n            }\n            int kSt = jL + 1;\n            int kEn = jR - 2;\n            if (kSt <= kEn && psize > 0) {\n                int lenQ = kEn - kSt + 1;\n                int lg = 31 - Integer.numberOfLeadingZeros(lenQ);\n                int iMax = Math.max(sparse[lg][kSt], sparse[lg][kEn - (1 << lg) + 1]);\n                gMax = Math.max(gMax, iMax);\n            }\n            ans.add(totalOnes + gMax);\n        }\n        return ans;\n    }\n}\n# @lc code=end