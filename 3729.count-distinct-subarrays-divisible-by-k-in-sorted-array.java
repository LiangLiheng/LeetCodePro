Step 1: Analyze the problem and input constraints to determine feasible solution strategies.
Step 2: Estimate the time and space complexity of potential approaches (e.g., brute-force, prefix sums, hashing) and compare against the input size constraints.
Step 3: If a potential approach is not scalable, decompose the problem and seek more efficient, general algorithmic patterns (e.g., using prefix sums and hashing for divisibility checks, leveraging sortedness for optimization).
Step 4: Explicitly leverage input properties such as sortedness, uniqueness, or monotonicity to guide optimization and reduce redundant computation.
Step 5: Integrate a verification/self-check step to confirm the feasibility and correctness of the solution for the largest allowed inputs before proceeding with implementation.
Step 6: After implementation, reflect on scalability, correctness, and potential general improvements for future tasks.