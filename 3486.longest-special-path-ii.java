#\n# @lc app=leetcode id=3486 lang=java\n#\n# [3486] Longest Special Path II\n#\n\n# @lc code=start\nclass Solution {\n    public int[] longestSpecialPath(int[][] edges, int[] nums) {\n        int n = nums.length;\n        @SuppressWarnings("unchecked")\n        java.util.List<int[]>[] adj = new java.util.ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            adj[i] = new java.util.ArrayList<>();\n        }\n        for (int[] e : edges) {\n            int u = e[0], v = e[1], w = e[2];\n            adj[u].add(new int[]{v, w});\n            adj[v].add(new int[]{u, w});\n        }\n        @SuppressWarnings("unchecked")\n        java.util.List<int[]>[] children = new java.util.ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            children[i] = new java.util.ArrayList<>();\n        }\n        build(0, -1, adj, children);\n        int[] cnt = new int[50010];\n        int[] res = new int[]{0, Integer.MAX_VALUE};\n        for (int i = 0; i < n; i++) {\n            int val = nums[i];\n            cnt[val] = 1;\n            dfs(i, children, nums, cnt, res, 0, 1, 0);\n            cnt[val] = 0;\n        }\n        if (res[1] == Integer.MAX_VALUE) {\n            res[1] = 1;\n        }\n        return res;\n    }\n    private void build(int u, int p, java.util.List<int[]>[] adj, java.util.List<int[]>[] children) {\n        for (int[] ne : adj[u]) {\n            int v = ne[0];\n            if (v == p) continue;\n            children[u].add(new int[]{v, ne[1]});\n            build(v, u, adj, children);\n        }\n    }\n    private void dfs(int u, java.util.List<int[]>[] children, int[] nums, int[] cnt, int[] res, int len, int nodes, int dupc) {\n        update(res, len, nodes);\n        for (int[] pr : children[u]) {\n            int v = pr[0];\n            int w = pr[1];\n            int x = nums[v];\n            int oldc = cnt[x];\n            int new_dupc = dupc;\n            boolean valid = true;\n            if (oldc == 2) {\n                valid = false;\n            } else if (oldc == 1) {\n                if (dupc == 1) {\n                    valid = false;\n                } else {\n                    new_dupc = 1;\n                }\n            }\n            if (valid) {\n                cnt[x]++;\n                dfs(v, children, nums, cnt, res, len + w, nodes + 1, new_dupc);\n                cnt[x]--;\n            }\n        }\n    }\n    private void update(int[] res, int len, int nodes) {\n        if (len > res[0]) {\n            res[0] = len;\n            res[1] = nodes;\n        } else if (len == res[0]) {\n            res[1] = Math.min(res[1], nodes);\n        }\n    }\n}\n# @lc code=end