#\n# @lc app=leetcode id=3721 lang=cpp\n#\n# [3721] Longest Balanced Subarray II\n#\n\n# @lc code=start\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int longestBalanced(vector<int>& nums) {\n        int n = nums.size();\n        if (n == 0) return 0;\n        int MAXL = n + 10;\n        int TSZ = 4 * MAXL;\n        vector<int> tree_min(TSZ, 0);\n        vector<int> tree_max(TSZ, 0);\n        vector<int> lazy(TSZ, 0);\n        vector<int> last_pos(100010 + 10, -1);\n        int ans = 0;\n        int total_even = 0;\n        int total_odd = 0;\n        auto build = [&](auto&& self, int node, int start, int end) -> void {\n            lazy[node] = 0;\n            if (start == end) {\n                tree_min[node] = tree_max[node] = 0;\n                return;\n            }\n            int mid = (start + end) / 2;\n            self(self, 2 * node, start, mid);\n            self(self, 2 * node + 1, mid + 1, end);\n            tree_min[node] = 0;\n            tree_max[node] = 0;\n        };\n        build(build, 1, 1, MAXL);\n        auto push = [&](int node, int start, int end) {\n            tree_min[node] += lazy[node];\n            tree_max[node] += lazy[node];\n            if (start != end) {\n                lazy[2 * node] += lazy[node];\n                lazy[2 * node + 1] += lazy[node];\n            }\n            lazy[node] = 0;\n        };\n        auto update_range = [&](auto&& self, int node, int start, int end, int l, int r, int val) -> void {\n            push(node, start, end);\n            if (start > end || start > r || end < l) return;\n            if (start >= l && end <= r) {\n                lazy[node] += val;\n                push(node, start, end);\n                return;\n            }\n            int mid = (start + end) / 2;\n            self(self, 2 * node, start, mid, l, r, val);\n            self(self, 2 * node + 1, mid + 1, end, l, r, val);\n            tree_min[node] = min(tree_min[2 * node], tree_min[2 * node + 1]);\n            tree_max[node] = max(tree_max[2 * node], tree_max[2 * node + 1]);\n        };\n        auto find_leftmost = [&](auto&& self, int node, int start, int end, int targ) -> int {\n            push(node, start, end);\n            if (tree_min[node] > targ || tree_max[node] < targ) return INT_MAX / 2;\n            if (start == end) {\n                return (tree_min[node] == targ ? start : INT_MAX / 2);\n            }\n            int mid = (start + end) / 2;\n            int res = self(self, 2 * node, start, mid, targ);\n            if (res != INT_MAX / 2) return res;\n            return self(self, 2 * node + 1, mid + 1, end, targ);\n        };\n        for (int r = 0; r < n; ++r) {\n            int x = nums[r];\n            int oldp = last_pos[x];\n            bool is_even = (x % 2 == 0);\n            if (oldp != -1) {\n                if (is_even) --total_even;\n                else --total_odd;\n                int delta = is_even ? -1 : 1;\n                update_range(update_range, 1, 1, MAXL, oldp + 2, MAXL, delta);\n            }\n            last_pos[x] = r;\n            if (is_even) ++total_even;\n            else ++total_odd;\n            int delta = is_even ? 1 : -1;\n            update_range(update_range, 1, 1, MAXL, r + 2, MAXL, delta);\n            int targ = total_even - total_odd;\n            int idx = find_leftmost(find_leftmost, 1, 1, MAXL, targ);\n            if (idx < INT_MAX / 2) {\n                int ml = idx - 1;\n                if (ml <= r) {\n                    ans = max(ans, r - ml + 1);\n                }\n            }\n        }\n        return ans;\n    }\n};\n# @lc code=end