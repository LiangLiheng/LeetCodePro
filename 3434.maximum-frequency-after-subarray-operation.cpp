Step 1: Read and understand the problem - Identify the inputs, expected output, constraints, and allowed operations

Step 2: Determine the algorithmic approach - Based on problem characteristics and constraints, identify applicable algorithmic patterns or data structures (dynamic programming, greedy, sliding window, hash maps, graphs, sorting, etc.)

Step 3: Design the solution - Outline the algorithm's core steps, select appropriate data structures, and verify time and space complexity meet the constraints

Step 4: Validate with edge cases - Systematically enumerate boundary scenarios (empty input, single element, maximum constraint values, all duplicates, extreme boundaries). For each scenario, construct a concrete example and trace through your algorithm step-by-step to verify correct output.

Step 5: Search for counterexamples - Actively attempt to find inputs that would break your algorithm. Ask: "Under what conditions would this logic fail?" Test scenarios where assumptions might be violated.

Step 6: Implement the solution in the specified programming language

Step 7: Present output as JSON with "reasoning" (your step-by-step thinking) and "result" (the code only) as string fields