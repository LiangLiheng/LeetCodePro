Step 1: Read the problem and extract the requirements, constraints, and input/output formats specific to the current task.
Step 2: Decompose the problem into actionable sub-steps, ensuring each step directly references the current problem's constraints and requirements.
Step 3: For each step, provide concrete reasoning and approaches tailored to the current task, including edge case identification and solution verification.
Step 4: Ensure the 'result' field contains a fully implemented, problem-specific solution in the provided template, and not any generic framework or meta-instruction.
Step 5: Before outputting, check that the output JSON includes only task-specific reasoning and code, conforming strictly to the requested format and template.