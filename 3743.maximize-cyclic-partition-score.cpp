â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸš¨ CRITICAL: THIS IS YOUR INTERNAL REASONING GUIDE - NOT YOUR OUTPUT ğŸš¨

This framework guides HOW you think through problems internally.
Your actual output must match the task's required format.
NEVER output this framework to the user - APPLY it to solve the task.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Step 1: Problem Analysis
- Read problem carefully, identify constraints, objectives, special conditions
- Extract key requirements that your solution must satisfy

Step 2: Strategy Formulation
- Develop approach to solve the problem
- Consider how to handle special structures or edge cases

Step 3: Example-Based Verification (BEFORE implementing)
- Manually trace your approach through at least one example
- Follow logic with concrete values, compare with expected result
- If mismatches occur, revise approach before implementing

Step 4: Complexity Analysis
- Count ALL nested loops systematically (outer: n times, inner: m times â†’ n*m operations)
- Calculate both time and space complexity
- For maximum constraint values, compute total operations
- Verify: does this fit within execution limits (~10^8-10^9 operations)?

Step 5: Alternative Exploration
- Ask: "What are fundamentally different ways to solve this?"
- Compare approaches (greedy vs DP, different representations, mathematical insights)
- If claiming optimization reduces complexity, verify by comparing operation counts
- Select approach balancing correctness and efficiency

Step 6: Implementation
- Write the actual solution code/calculation/response
- Handle edge cases and boundary conditions
- Use appropriate data types

Step 7: Final Verification
- Calculate operations for maximum constraints (substitute max values into complexity formula)
- Verify edge cases work correctly
- Confirm all problem requirements satisfied
- **Format Check**: Will your output match the EXACT format specified in the task?

Step 8: Deliverable Production - TRANSITION FROM THINKING TO OUTPUT

ğŸ”´ PRE-OUTPUT VERIFICATION (Answer before finalizing):
Q1: "Is what I'm about to output the actual artifact requested (executable code, calculation, formatted response), or a description/plan/methodology?"
Q2: "Can someone directly use/execute what I'm outputting, or would they need to implement it based on my description?"
Q3: "Does my output match the task's specified format, or does it match this framework's format?"

If any answer suggests description/methodology, STOP and revise.

ğŸ”´ EXECUTION:
- Re-read the original task to identify exact output format required
- Produce the actual deliverable in that format
- Verify format matches task specification (NOT this framework)

ğŸ”´ FINAL SANITY CHECK:
"I am outputting [describe specifically]. Does this match the task's required format? If it looks like methodology/framework/description, I must produce the actual artifact instead."

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
REMINDER: Your reasoning process (Steps 1-7) stays internal.
Only the concrete artifact from Step 8 goes to the user.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•