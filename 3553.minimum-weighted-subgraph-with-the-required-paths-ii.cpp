#\n# @lc app=leetcode id=3553 lang=cpp\n#\n# [3553] Minimum Weighted Subgraph With the Required Paths II\n#\n\n# @lc code=start\nclass Solution {\npublic:\n    vector<int> minimumWeight(vector<vector<int>>& edges, vector<vector<int>>& queries) {\n        int n = edges.size() + 1;\n        vector<vector<pair<int, int>>> adj(n);\n        for (auto& e : edges) {\n            int u = e[0], v = e[1], w = e[2];\n            adj[u].emplace_back(v, w);\n            adj[v].emplace_back(u, w);\n        }\n        const int LOG = 18;\n        vector<vector<int>> par(LOG, vector<int>(n));\n        vector<long long> dep(n);\n        vector<int> level(n);\n        vector<bool> vis(n, false);\n        queue<int> q;\n        q.push(0);\n        vis[0] = true;\n        par[0][0] = 0;\n        dep[0] = 0;\n        level[0] = 0;\n        while (!q.empty()) {\n            int u = q.front(); q.pop();\n            for (auto& p : adj[u]) {\n                int v = p.first;\n                int w = p.second;\n                if (!vis[v]) {\n                    vis[v] = true;\n                    par[0][v] = u;\n                    dep[v] = dep[u] + w;\n                    level[v] = level[u] + 1;\n                    q.push(v);\n                }\n            }\n        }\n        for (int k = 1; k < LOG; k++) {\n            for (int i = 0; i < n; i++) {\n                par[k][i] = par[k - 1][par[k - 1][i]];\n            }\n        }\n        auto get_lca = [&](int uu, int vv) -> int {\n            int u = uu, v = vv;\n            if (level[u] > level[v]) swap(u, v);\n            int diff = level[v] - level[u];\n            for (int k = 0; k < LOG; k++) {\n                if ((diff >> k) & 1) {\n                    v = par[k][v];\n                }\n            }\n            if (u == v) return u;\n            for (int k = LOG - 1; k >= 0; k--) {\n                if (par[k][u] != par[k][v]) {\n                    u = par[k][u];\n                    v = par[k][v];\n                }\n            }\n            return par[0][u];\n        };\n        auto get_dist = [&](int u, int v) -> long long {\n            int l = get_lca(u, v);\n            return dep[u] + dep[v] - 2LL * dep[l];\n        };\n        int m = queries.size();\n        vector<int> ans(m);\n        for (int j = 0; j < m; j++) {\n            int s1 = queries[j][0], s2 = queries[j][1], d = queries[j][2];\n            long long total = get_dist(s1, s2) + get_dist(s1, d) + get_dist(s2, d);\n            ans[j] = total / 2;\n        }\n        return ans;\n    }\n};\n# @lc code=end